***tüm sayfa görüntüsü***************
takescreenshot ile driver casting yapıyoruz

1-TakesScreenshot ts= (TakeScreenshot)driver;

2-kaydettiğimiz ekran görüntüsünü projede istediğimiz yere kaydebilmek için path ile yeni bir File oluşturalım
File tümResim=new File("target/ekranresmi/tümSayfa);

3-TakeScreenshot objesini kullanarak(ts) getScreenshotAs methodunu çalıştırarak ve resmi geçici bir file assign edelim

File resimGecici=ts.getScreenshotAs(OutputType.FILE);

4-geçici kaydettiğimiz resmi saklamak istediğimiz yere kaydelim.

FileUtils.copyFile(resimGecici,tumResim)
//////spesific webelement screen shot////
1-Webelement locate edelim

Webelement logoElementi=driver.findElement(By..);

2-ekran görüntüsünü kaydecegim yerin path ile file oluştur

File logoResmi=new File("target/ekranResmi/element");

3-webelement üzerinden getScreenShot methodu kullanarak geçiçi bir dosyaya assign edelim

File logoGecici=logoElementi.getScreenshotAs(OutputType.File);

4 gecici resmi asıl dosyasına atalım.
FileUtils.copyFile(logoGecici,logoResmi);

****tüm ekran görüntüsünü seleniumdan gelen getScreenshotAs methodu kullanarak elde edilir
****getScreenshotAs methdu seleniumdaki TakesSecreenshot api dan gelir.(ekran ile selenium arasında garsonluk yapıyor api)
****----//*[contains(text(),'AAAAA')]

**custom html reportları hazırlaya biliriz
**extentReport
extentHtmlReport
extentTest logları yazdır.

***//table[@id='table1']//tbody//tr[3]//td[.='serdar']


****excell sayfası oluşturup test etme
**pomxml sayfasına apachi poi ve apachi oomlx depencieslerini koymalıyız.
*--java dosyasını sağ tıkla ve resources adında bir klasör oluştur.proje bazında da olabilir
*-excel dosyasını at .
bu resources dosyasına excel word text ... gibi dosyalar atılabilir.birden fazla dosyada olabilir. 
 String path="./src/test/java/resources/ulkeler.xlsx";
FileInputStream fileInputStream=new FileInputStream(path);
Workbook workbook= WorkbookFactory.create(fileInputStream);
    Sheet sheet1=workbook.getSheet("Sayfa1");
Row row1=  sheet1.getRow(0);
        //ilk satırdaki ilk veriyi al
        Cell cell1=row1.getCell(0);

  Map<String,String> ukleBaskentleri=new HashMap<>();

        for (int satirSayisi = 1; satirSayisi<kullanilanToplamSayisi ; satirSayisi++) {
           String country= sheet1.getRow(satirSayisi).getCell(0).toString();
           String baskent= sheet1.getRow(satirSayisi).getCell(1).toString();
           ukleBaskentleri.put(country,baskent);
        }
        System.out.println(ukleBaskentleri);


    }

***WRİTE EXCELL*******
 @Test
    public void writeExcelTest()throws Exception{
        String path="./src/test/java/resources/ulkeler.xlsx";

        //dosya yı aç
        FileInputStream fileInputStream=new FileInputStream(path);
        //excel dosyasını aç workbooku aç
        Workbook workbook= WorkbookFactory.create(fileInputStream);

        //sayfayı aç sheet1
        // Sheet sheet1=workbook.getSheetAt(0);//index 0 dan başlar ilk sayfayı aç veya
        Sheet sheet1=workbook.getSheet("Sayfa1");

        //ilk satıra git row
        Row row1=  sheet1.getRow(0);

        //ilk sutun 4.stun create et
        Cell cell4=row1.createCell(3);///dikkat
        //nufus yaz
        cell4.setCellValue("BASKENT");///dikkat

        sheet1.getRow(2).createCell(4).setCellValue("450000");
        sheet1.getRow(3).createCell(4).setCellValue("600000");


        //KAYIT İSLEMI FILE OUTPUT STREAM İLE YAPILIR
        FileOutputStream fileOutputStream=new FileOutputStream(path);
        workbook.write(fileOutputStream);
    }

tekrar
*microsoft dosyalari ile iletişime geçmek için apache poi dependency kullanilir.
->dosya/workbook/sheet/row/cell
getLastRowNumber
getPhsicalNumberOfRows
**JS EXECUTORS 

**java executer seleniumun parçası javascript executor javascript kodlarını okumaya yarar.bir butonun rengini değiştirmek için kullanılır.selenium yetersiz kalabililr.
click,belirli bir elemente scroll etme type input vb.
***what we can do with js executor?
click.hidden elementler.
saga sola aşagı yukarı  ve belirli element görünene kadar scroll
inputlara yazı deger atama yazma
elementlerin renklerini değiştirme araka rengini değiştirme border(çerçeve) ekleme.

**input tagı içindeki verileri js ile değiştirebilirim. value değeri gibi
**input taki degerleri ancak js execute ile alabilirim genelde id kullanarak bulurum
--javascript executor nedir
-**seleniumdan gelen ve javascript kodlarini çalıştırmaya yarayan bir interfacetir.normal selenium methodlarinın yeterli olmadığı durumlarda kullanılabilir
ne zaman ve nasıl kullandın
-**sayfanın kaydırılma , click işlemleri, yada input kutularındaki değerleri almak için ve type yazdirmak için
sayfayi aşagı yukari kaydirma islemi selenium nasıl yapılir
-** actions yada javascript executor methodları
actionslarda page_up,page_down, arrow_down, arrow_down yada js executor ile scrollintoview(true) method ile alinabilir.reuseable method oluşturmuştur
selenium da click yaparken problem yaşadın mı
-**evet yanliş locator,bekleme problemi,hiden gizli elementler tıklarkende java script  executor kullandım çözdum. java script browser ın dili.unutma
selenium otomasyonunda ne tur problemler yaşadın
 -** Teknik problemler=yanlış locator,bekleme(wait),alert,iframe ,pop-up,multiple window,hidden elementlere tiklama,capche,
2-takımla ilgili problemler(çok gundeme getirilmemeli).

*****LOG4J//////////////////////////////////////////////////
-*AYRI BİR APİ depend.
-*loglamak. damgalamak yazırmak için kullanilir bilgi hata debug //system.out.print gibi
-*consola yazi yazdırabilirim ayni zamanda bir dosya oluştur içine yaz.extend report gibi screen shot gibi
**developerlar daha kullanılır.
**çeşitli seviyelerde loglama yapılabilir uyari bilgi debug fatal warn
log4j kullanıyoruz projemizde
-* log4j kullanılırsa zaman bilgisi-kalıci dosya oluşturulabilir. fatal error info debug yazilalari yazdirilabilir.
/////,
 private static Logger logger= LogManager.getLogger( C02_Log4j.class.getName()); içine klass adı.class unatma
    @Test
    public void log4JTest(){
        //logger objesi ile yazdırma işlemi yap //defoult olarak fatal ve erroru verir
        logger.fatal("Fatal log!");
        logger.error("Error log!");
        logger.warn("Warn log!");
        logger.debug("Debug log!");
        logger.info("Info log!");

    }

1-dependencileri ekle
2-class aç yukaridaki gibi
3proje seviyesinde resources dosyasi oluşturmaliyız. ayar dosyası xml. dosyası olacak bunun altına log4j2.xml file dosyası oluşturalım

//*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/

Xpath Seçicileri çeşitli biçimlerde bulunabilir:

Standard Xpath 1-driver.findElement(By.xpath(“//input[@id= ’login-username’]”))
Contains     2 driver.findElement(By.xpath(“//input[contains(@name, ‘q’)]”))
AND & OR 3 OR için syntax: Xpath=//input[@class=’value of id’ OR @name=’value of name’]    AND için syntax: Xpath=//input[@class=’value of id’ AND @name=’value of name’]
Starts-with  driver.findElement(By.xpath(“//input[starts-with(@class,’gLFyf’)]”))
Text  Syntax: Xpath=//div[text()=’value of text’]

2)CSS Selector Kullanımları

CSS Seçicileri çeşitli biçimlerde bulunabilir:

Tag ve ID driver.findElement(By.cssSelector(“a#login”)) id yerine #
Tag ve Class     driver.findElement(By.cssSelector(“div.SearchBoxOld-buttonContainer”))  # yerine . kullanılır.
Tag ve Attribute    Syntax: css= (HTML Tag)[Attribute=Value]
Tag, Class ve Attribute   Syntax: css=(HTML Tag)(.)(Class)([attribute=’Value of attribute’]) driver. findElement(By.cssSelector(“input. inputtext login_form_input_box [name = ‘pass’]”))
Matches (Starts with, Ends with, Contains)---  Syntax: css=(HTML tag)([attribute^=’start of the string’])  driver.findElement(By.cssSelector(“input[name^=’em’]”))--
**
Syntax: css=(HTML tag)([attribute$=’end of the string’])

Bu elementin Css Selectorunu Ends With yöntemiyle yazalım;

driver.findElement(By.cssSelector(“input[name$=’ail’]”))

**
Syntax: css=(HTML tag)([attribute*=’partial string’])

Bu elementin Css Selectorunu Contains yöntemiyle yazalım;

driver.findElement(By.cssSelector(“input[class*=’control’]”))


Child elementler

Syntax: Css= tagname . class name li : nth-of-child(child element indexi)
////////////////////************************************************************************************
maven selenium junit apache poi java faker apache core
SKİLLS
-languages:
java,lamda,xml,sql,html,css
-frameworks :
JUnit,TestNG,Cucumber
-Desing pattern:
page object model
-tools:
selenium webdriver-testNG-cucumber-maven-postgreSQL-JDBC-INTELLİJ,ECLİPSE,JİRA,Jmeter,postman,restful api,selenium grid,
git,github,awc e2e,APPIUM
version control sistem:
git,bitbucket(jira ile aynı şirket ücretli)
Front End Testing:
selenium Webdriver
APİ TESTİNG:
postman for manuel testing,Restful for automation 
BACKEDEND/DATABASE TESTİNG:
SQL JDBC
CONTİNOUS İNTEGRATİON(CI,CD),CONTİNOUS DEPLOYMETN(CD):
Jenkins
REMOTE TESTİNG:
Selenium Grid,jenkins
*****************************************************************************************************

/*/********///*/*///////////////////////////////////////
TEST NG KONULARI
Anotains
Test Gruplari
TestNG xml dosyalari
data provider
paralel testing
PAGE OBJECT MODEL

***
NEXT GENERETİON KELİMELERİNDEN GELİYOR.CEDRİC BEUST YAPMIŞ
AÇIK KAYNAK-TESTNG BİR KÜTÜPHANE
SADECE JAVA İLE ÇALIŞIR.JDK 7 VE ÜSTÜ OLMALI.
5 BEFORE 5 AFTER METHODU VAR
JUNİTE 2 BEFORE 2 AFTER METHODU VARDIR.
**dataprovider sadece testng var.
**listener
**xml dosyaları
**---priority
**---dependsOnMethod
**--paralel ve cross-browser test yapabiliriz
**-html ve xml raporlarına imkan sağlar

////TESTNG PROJE OLUŞTUR////
---yeni bir maven projesi oluştur
--javanın altına tecproed dosya oluştur.
*tecproed sağ tıkla tests
*techroed sağ tıkla utilities
*techproed sağ tıkla pages dosyalarını oluştur
depencylepere 
*selenium java-junittede kullandık
*webdrivemanager-junittede kullandık
*testNG YÜKLE yeni

***afterclass anotation ı herzaman statik olmalı public static void afterClass(){} gibir

    /*
    suite:proje farklı anlamları var smoke testlerde göreceğiz
    @Test: test case oluşturmak için kullanılır
    @Before ve @After :5 before 5 after anotations var
    suit>tests>grup>class>method
    @BeforeSuit: her bir test suite den önce 1 kere çalışır
    @AfterSuit: her bir test suite den sonra 1 kere çalışır
    @BeforTest: her bir testen önce(test case değil) 1 kez çalışır
    @AfterTest: her bir testen sonra 1 kez çalışır
    @BeforeClass: her bir classdan önce bir kez çalışır
    @AfterClass: her bir classdan sonra bir kez çalışır
    @BeforeMethod: her bir @test anotationdan önce bir kez çalışır.Junitte karşılıgı @Before
    @AfterMethod: her bir @test anotationdan sonra bir kez çalışır.Junitte karşılıgı @After
    @Ignore : @Test caseleri çalıştırmak istemez isek skip
    anable():false veya true şarteli kapat
    testNG de testler naturel order ile çalışır isim sırasına göre çalışır
    Test caseleri öncelemek için priority ile sıraya koyabiliriz
    @Test(priority=7)
     */
*/////////////dependsOnMethods************************//
dependOnMethod: testleri bir birine bağımlı olacak.homepage ()///searchPage örneğindeki gibi
hometest geçmez ise searchTest çalışmaz.searchTest ignore olur.
  @Test
    public void homeTest(){
        System.out.println("homeTest");
        Assert.assertTrue(false);//bilerek fail yaptık
    }
    @Test(dependsOnMethods = "homeTest")
    public void searchTest(){
        System.out.println("searchTest");


-*---hard assertion JUNİT TESTNG CUCUMBER DA VAR
assertion failed olursa ondan sonraki satirlar çalışmaz stop execuition

*---softassertion sadece testNG VAR
eğert bir adım failed ederse testler devam eder.sonunda verir geçen geçmeyen testeleri verir.
sortasert objesi oluşturulmalı.
SoftAssert softAssert=new SoftAssert;
 softAssert.assertTrue();
softAssert.All(); bunu kullanmak şart aksi halde herşey pass olarak gösterir.

amaçları farklı olsada methodlari ayni

/*/*/*/*/*/*/Page Object Model/*/*/*/*/*/*/*/*/*/*/
-elementleri depolayıp tekrar tekrar kullanabiliriz
-maintable tamir edilebilir kodlar değiştiğinde tek yerde değişiklik yapmak yeterli olacak
-reusable objeler sayesinde tekrardan kurtulacağız
understandable daha anlaşılır ve faster

bir sınıfta webelementleri tanımlıyoruz 
@FindBy(id="dafd") 
public Webelement username;
anotasyonu ile locateleri tanımlıyoruz. aynı sayfaya method da yazabiliriz.

özel pagelar özel sınıflar özel filelar
***driver classı oluştur
***.properties file oluştur proje seviyesinde configuration dosyası
***config reader sınıfın amacı configuration.properties dosyasından verileri almak için yapılır başka bir amacı yok
**static block nedir. config reader da kullandık
**Singleton design statik ve public yaptık tüm projede tüm sınıflar aynı şekilde ulaşacak ayrıca farklı driverların üretilmesini engelleyecek
**Driver class larda frameler kullanılır statik driver ayrıca getDriver methodu
**dosya okumak yazmak java sınıfı oluşturmak lazım.configReader gibi seleniumla dosya okuyamayız.


******smoke test nedir****************************************
her gün yapılan programın en önemli özelliklerinin test ettiğimiz testtir.
-login
-checkin
-Checkout
-add to card
-make payment
-sign out
*her sabah 8 de jenkins kullanılabilir.15-20 dakika sürer.jenkins raporlar her otomatik.virtual machine ve ya local bilgisayarınızda da olabilir.
*smoke bir clasör olur.içine smoke test caseleri yazarız.
-smoke testinizde kaç test var 15-20 arası olabilir.
-tüm smok test caselerimizi automate edilmiş midir.önemli olanların hepsi outomate edilmiştir.
-hangi testlerin smoke test e ekleneceğine kim karar verir? Test lead sr automation tester.en kıdemli tester.qa 

*************Regression test nedir**************
*tüm ana fonksiyonların majorın test edildiği test tipidir.genel saglık kontrolü.ekleme çıkarmaların etkisi olcülür
-Smoke test +(müsteri profili ile yapılsin)
-diğer müşteri hizmetleri ,admin,tech support bu yerlere girdiğinde hangi arayüzü görür
-farklı ödeme sistemleri dener (paypal amex visa mastercard
-ne sıklıkla yapılır?
production bug fix lerden sonra
major ana releaselerden önce örneğin biz 6 ayda bir release yaparız
-regression test ne kadar sürer?
6-7 saat sürebilir.bazı manuel test caseler varsa ise test süresi uzar.
-bir regression teste kaç test case vardir?500 den fazla test case var.
-tüm regression testlerimiz automation edilmiş midir?
hedefimiz tüm regression testlerimizin automate etmek fakat bu pek mümkün olmuyor.yüzde 80 civarı
-hangi testlerin hangi regression test olacağına kim karar verir.
 Test lead sr automation tester.en kıdemli tester.qa 
-**Outomate edilmeyen bir durum.
***----***dogruma gerektiren storylerde automate edemiyoruz.telefonlara şifre geliyor capche gibi
****----***aşırı guvenlikli durumlar
***--***bazı teknik user storyler sadece developerlar ile alakalı olabilir.testerlerin onlariın environmentlarına accesleri mümkün olmuyor.

*/////******excel automation**
datalar dışardaki bazı dosyalardan gelebilir
external files-config.properties-excel-json-Xml-database-APİ-faker dan data gelebilir.veri havuzları.
*/1-excel için maven reporstory den apachi poi.  poi oooxml ile birlikte
2-resource dosyası test-java klasörünün altına dosya oluştur.excell dosyasını oraya at
3-excell utilste reuseable methodlar oluşturmalıyız
4 test case oluşturabiliriz

*****./ önceki kısımları umursama görme "./src/test/java/resources/mysmoketestdata.xlsx";

******************DATA PROVİDER---------------------------------
-veri havuzu oluşturmak için.
sadece TESTng de var***
**return tpe 2 boyutlu array dir.
**2 tane parametre kullanılabilir
name ve paralel zorunlu değil.
/*getwindowhadle return tpi set.


   veri deposudur.
    **2 boyutlu array ve objec uretir
    **sadece test ng nin bir özelliğidir
    DDT DATA DRİVEN TESTİNG İÇİN BİRDEN FAZLA DATAYİ TEST ETMEK İÇİN KULLANIRIZ
    *@DataProvider annotasyonu ile veri havuzu oluşturuz.@test methodlarına dataProvider parametresi ile baglanır
    2 adet parametre vardır.
    ***name:method ismi override etmek için yani farkli bir isim ile data provideri çağırmak için kullanılir
    ***parallel :paralel test case oluşturmak için kullanılır
    **dataprovider la browserdan veri alamaaayız

****DATALARI EXCELLDEN DATAPROVİDERA ÇEKMEK*******

  @DataProvider
    public Object[][] customerData(){
        //dataprovider test2 den farkı dataları excelden aldık.bu kullanım daha iyidir.
        String path="./src/test/java/resources/mysmoketestdata.xlsx";
        String sheetName="customer_info";
        ExcelUtils excelUtils=new ExcelUtils(path,sheetName);

        Object[][] müsteriBilgiler=excelUtils.getDataArrayWithOutHead();


        return müsteriBilgiler;
    }

***control alt L CODE FORMAT
xml file ////////////////////////xml file
1.yol
ayar dosyası.
xml dosyasında belirli classları ,methodları düzenli şekilde çalıştırabiliriz.
TestNG xml dosyaları testleri otomotik olarak çalıştırmaya yarar. paralel test ve listenerları bunla kullanılır.
***suitleri ,test package larını, classları veya methodları çalıştırırız.ayrıca gruplar da var
***include /////exclude  flexiblity esneklik kazandırır.
https://testng.org/doc/documentation-main.html bilgi için
verbose="1" consoldaki bilgi miktari 2,3 olabilir hiç olmayabilir

test ng plugin****** 2. yol
FİLE-AYARLAR-PLUGİN-TESTNGXML İNSTALL sonra tekrar başlat.
yüklü ise herhaangi bir dosya üzerinden sağ tıkla xlm oluştur.


<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="minor regression">
    <test verbose="2" name="regression1">
        <packages>
            <package name="techproed.*"></package>
        </packages>
    </test>
</suite>

***git github confilict çözümü****
1-kendi kodlarını bir yere kaydet word gibi
2-projeyi sıfırdan clone et
3-kendi kodlarını sıfırdan ekle
4-git pull
5-git add . git commit git push


TESTNG PARALEL TEST
1-Sequntial testing test1->test2->test3
2-paralel test aynı anda birden fazla test çalıştırılması.test zamanını azaltmak için zaman kazanmak
**paralel : paralel kelimesi ile xml dosyasında kullanılır
**thread-count -> tarayıcı sayısı veya code sayisi 
1-paralel test Dataprovider ile de yapılabilir.kısıtlı kullanım*****
@DataProvider(paralel =true)
xml file:
paralel test için kullanılır
data-provider-thread-count=Thread(code veya tarayici )sayisi
2-xml file ile***********************************************
paralel test için kullanılır
thread-count=Thread(code veya tarayici )sayisi
<suite name="All Test Suite" parallel="classes" thread-count="3"> 
test ng frame workünde çalıştırmak sıkıntı çünkü singlton driver kullandığımızdan.

////******LİSTENERS***************---------------------///
İNTERFACE 8 çeşit ITESTLİSTENERS
-Listenerslar ile testng frame workü modify ederiz.
-xml dosya olmadan da listenerslar çalıştırılır ama xml ile daha iyidir.
1-@Listeners anotation ile
2-testng.xml file ile çalıştırabiliriz.
seleniumdaki kodları dinler.fail eden testleri dile getirir.neden kaldı.skip olanı yazar.kısaca raporlamayı iyi yapar.
test case sonuclarını exception errors testlerin başlama bitiş anlarının geçmelerini fail durumlarını dinletir bize
-hatta sayfa geçişlerini,button tıklama,data girme,loglama içinde kullanılır.log4j,extendReport,
sadece TESTNG ÖZEL.
7 testmethodu var Itest TE

--onStart(ITestContext arg0) methodu
tüm testlerden önce birkez çalışır(@BeforeSuite gibi)

--onFinish(ITestContext arg0) methodu
tüm testlerden onra birkez çalışır(@AfterSuite gibi)

--onTestFailure(ITestResult result) methodu
sadece fail eden testlerden önce çalışır

--onTestSkipped(ITestResult arg0)
ignore edilen testlerden hemen sonra çalışır atlanan

--onTestStart(ITestResult arg0)
her bir testten sonra bir kez çalışır(@AfterMethod benzeri)

--onTestSucces(ITestResult arg0)
sadece pass eden testlerden hemen sonra çalışır

--onTestFailButWithinSuccesPercentage(ITestResult arg0)
belirli bir test Fail sonrası çalışır

1-utils da LİSTENER CLASS OLUŞTUT
2.implement ITestListener interface . bu test basse class gibidir
3-ITest methodları ekle 7 tane yukarıdaki
4-test package da yeni bir packagea ac :listeners
5.listener packagenın altına yeni clas oluştur :ListenesTest
not test claslar ile listenerları ilişkilendirmenin iki yolud vardır.
1-@Listeners annotation  @Listeners(techproed.utilities.Listeners.class)  //test clasında clas sviyesinde yazılır
2-xml file ile ve listeners tag kullanarak
<listeners>
<listener class-name="techproed.utilities.Listeners">  //suiten sonra tamımla
<listeners>

**kalan testleri istediğimiz kadar tekrar çalıştır.**********LİSTENERSRETRY***********İNTERFACE
1.UTİL clas oluştur ımplement et RetryAnalyzer 
2-test sınıfı ile retry ile ilişkilendir @test(retryAnalyzer=techproed.utilities.ListenersRetry.class) -methodla ilişkilendirilir.
3-sonuç herhangi bir test fail ederse bunu .... kez çalıştır ve sonuç aynı ise fail ver
**REtry ı testng xml dosyaları ile de çağırabiliriz.
***ListenerRetryAnalyzer tüm fail test caselerin çalıştırılmasını sağlar.
*----listeners->ITestListener implement ediyor
*---listenersReTry-> IRetryAnalyze implement ediyor
*---IRetryAnalyze->IAnnotationTransformer implement ediyor utils clasta dikkat et.


testng den geliyor apı değil interface tir listeners ve listenerstry

TESTNG REPORTS-//*/*/*/**
//eclips kullanıcılarının en çok sevdiği rapor çesidi testng reports.biz inteligent kullanıyoruz.
Eclips:test-output dosyası testng non xml raporları otomatik olarak oluşur.
Intelij: bu dosyanın oluşması için mini bir ayar yapmak gerekir

--smoke test e sağ tıkla xml file dosyası oluştur
--run et sonra
--projeyi tıkla ->Run-> Edit configuration
--xml dosyasını seç Listeners-> + tıkla>reportları ekle
APPLY >OK
xml i run et
--proje yenile
--Test-output dosyasında raporlar çıkmalı
-sadece test ng de olan bir rapor
**bu yaptımız xml file dosyasında pagelarımızı ,classlarımızı çalıştıra biliriz.log4j deki gibi reporter.log  sınıfını çağırarak sınıf içinde yaptımız
işleri raporlaya biliriz.



RECAP-1 **********************RECAP-1*******************

/////-----------------------MAVEN-------/////////////////////////////////////////////

-java Projesi oluşturmak için kullandığımız bir araç.project built tool
-jar dosyalarıyla ugraşmak yerine pom.xml dependencieslerde eklentileriyle proje oluşturulur.
-bir yemeğin tenceresi.selenium -testng-java faker-apache eklentileri
-içene rapor ekleyebiliyoruz.
-mvn clean özelliği ile classları çalıştırabiliriz
*---*maven alternatiflari nelerdir.
Gradle,android,groowy,kotlin,java,ant bunlar project built tool
-maven is used to built project,run to project,deploy to project

********SELENİUM*************
1-selenium nedir niçin kullanılır
-jar dosyası .bir api.bu dosyada birçok hazır class ve method vardır.
-bu class ve methodlar web atomasyonu için kullanılır.
-farklı kodlama dilleri ile çalışır(java ,c#, pyhton..
-farklı işletim sistemleri ile çalışır(macos,windowa,linux
*-Selenium ile direk olarak mobil test ve desktop otomosyonu yapılamaz.ama third-party araciyla mobil(APPİUM) desktop otomasyon selenium ile yapılabilir
*-auto it,robot class yardımı ile yapılabilir.
-windowshandle,actions,iframe,alerts,dropdown,cookies,webelementlerin bulunması,klavye ve mause,javaexecuter ile çalışır.extent reports,@findby seleniumdan geliyor
*********JUNİT*************
1-JUNİT nedir nerede kullanılır
-junit bir test frameworkudür.
-test oluşturmak(@TEST),before/after annotasyonları, Assertion(asert) lerde kulllanılı
-junit eski ve basilt bir test framworkudur.advanced şekli TestNG DİR
-genelde developerlar unit test lerde için kullanırlar
-selenium gibi jar dosyası.executeable.sıkıştırılmış çalıştırılmış.farklı farklı kütphaneler var
**************TESTNG*****************************************
1-testNG bir test frame workudur
-bir jar dosyasıdır
-test oluşturmak(@TEST),before/after annotasyonları, Assertion(asert) lerde kulllanılır
-ek olarak before grups, beforeTest,beforSuite
-soft assertion
-DependsOnGroups,DependsOnMethods
-TestNg LİSTENERS (ITestListeners,IRetryAnalyzer,IAnnotationTransformer)
*kodları dinlerr(pass ,fail,skip)
*test fail ettiğinde fail testen hemen sonra ekran göruntüsü alabiliriz
*fail testlerini tekrar tekrar run ettirebiliriz.
-TestNG XML dosyaları .xml
-test caseleri run etmek için, 
-belirli method,class,paket, ve gruplar için xml dosyaları oluşturup o xml dosyalarına eklemiş olduğum test caseleri çalıştırabiriz
 frameworke ek özellikler getirmek için ve ek ayarlar
*test grupları oluşturmak için
*paralel test
*cross browser test bir testcase i önce chrome sonra firefox ta çalıştır diye biliriz
*smoke testlerin çalıştırılması
*regression testlerli çalıştırılması
*listeners ların kolay çalıştırılması için
-paralel test yapılabilir paralel thread-count key wordleri.
testNG raporlar. run-edit configuration-raporları ekliyoruz
-Emailable reporter
-failed reporter
-test html reporter
-suit html reporter
*dataprovider
-data kaynagı olarak kullanılır.
-dataların test caselere aktarır.
-en önemli özelliklerinden biri dataları otomatik olarak itereate etmesidir.loop kullanmaya gerek yok
-data provider ile paralel test yapılabilir
***cross browser için selenium grid şart değil

-İNTERVİEW
1-Release (birakmak,yayınlamak)e katildın mi;
yılda 2 önemli (major fall ,spring) release, 4 minor release olur.
-update release lerden sonra gelir.
her bir release den önce regression testi yapılır.RELEASE de tester da hazır bulunur.
Release leree product owner ve regression testerlar aktiftir.

****FİLE UPLOAD -DOSYA YÜKLEME**********
1.<input id="file-apload" type="file" name="file">
**** bu html kodu INPUT TYPE FİLE file apload elementi oluşturmak için kullanılır.

driver.get(""https://www.dfdfdafaf.com");
-choose file dosyasına basalım
Webelement chooseFileButton=driver.findElement(By id("njnknjkn"));
String dosyaYolu=System.getProperty(user.home)+"/Desktop/logo.png";
chooseFileButton.sendKeys(dosyaYolu);
--upload butonuna bas.
driver.findElement(By.id("file-submit")).click();
1-<input type="file" ----sendKeys methodu
2-<button type="button">Select Files</button>
      a)Robot class = seleniumda desktop işlemleri için kullanılır. javadan gelir
**actionlara benziyor.
      b)Auto It seleniumda desktop işlemleri kullanılır

önemli***
unhandleAlertException neden maximize yaparken hata aldık.
switchto  kullandığımızdan alert kutucuğu maximise yapamadığından hata verir.her driver.get methodunu çağırdımızda maxi yapar.
driver ı //yoruma almaliyız veya try catch kullanabiliriz.


/*****************CUCUMBER*******************************



////BDD/// behavior driven development//CUCUMBER START
cucumberin dili gherkin dili
Feature file
Feature epic
Scenario test case
Given stepler
And
Then
**davranışlar tanımlanır
**agile methodolijisinde code bilmeyen kişiler olabilir
**anlaşılabilir ingilizce veya türkçe kullanılır
**TDD TEST DRİVEN DEVELOPMENT.
hibrit frame work 
cucumber ,junit ve testng ile kullanılabilir.ama biz cucumbe-junit kullanıcağız
cucuber raparu
extent rapor
cucumber jbm güzel bir rapor
reuseable test adımları


1-Create project:file-new-prject-select maven-click next
2-name:ahmetBayram-cucumber
3-add dependencies=selenium-java,webdrivermaneger-cucumber java-cucumber junit
4-click maven=click"Enable auto-reload after any changer" bu mesaj görünmeye bilir
5-javanın sürümü ile alakalı sorunları hal etmek için
<properties>
<maven.compiler.source>1.8</maven.compiler.source>
<maven.compiler.target>1.8</maven.compiler.target>
</properties>
6-java sağ tıkla aşagıdaki paketleri oluştur
a-utilities
b-pages
c-runners test caseleri çalıştırmak ve kontrol etmek için kullanacağız
d-stepdefinitions (kodlarımızı burda oluşturacağız)
7-projeye sağ tıkla configuration.properties dosyası oluştur
8-utilities paketi altında Driver ve ConfigReader dosyası oluştur
9-test paketi altında yeni klasör oluşturalım :resources
10-resources klasorünün altına yeni bir klasor oluşturalım :features java kodu içermeyen dosyaları buraya  koyacağız
11-features sağ tıkla yeni dosya oluşturalım:ilkfeaturefile.feature
12.cucumber plugin i intellij e ekleyelim (settings/plugins)
a( mac) Intellij Idea->Preference-plugins-marketplace-Type Cucumber for Java-Install-restart
b (windows) file->setting-plugins-marketplace-Type Cucumber for Java-Install-restart

@Wip work in project
*adımları manuel test yapar gibi tüm adımları yazılır
-gherkin language zorunlu .feature uzantlı dosya oluşturmamız lazım.
given
when
then
and
TDD VE BDD  JUNİT VE TESTNG KULLANABİLİRİZ
excelle yaptıgımız herseyi cucumber da var.

-**resource dosyası kaynak dosyamız directory olarak oluşturuyoruz.directory=package / 
bunun altında yeni directory olarak features folder ı oluşturacağız.bu dosyayı cucumber a tanıttık
**.feature dosyası yesil ise sorun yok. gri ise plugin kurmak lazım.cucumber plugin kurmak lazım.file+setting-plugin-marketplace-cucumber for java -installed-
-gherken installed

**.feature dosyası 
  # her feature file,Feature:kelimesi ile  başlamak zorunda EPİC diğer adı.testsayfamız
  # her bir file da yanlız bir Feature:  kullanılabilir.Feature: 
  # Test caselerimizi  Scenario(test case) da yazarız
  # verification yapmak istediğimiz adımlar da Then le başlamak önceliğimiz olmalı.ortalar when ve and
  #  her bir file de birden fazla scenario kullanılabilir
  # her bir adim Given When And Then But * kelimeler anahtar kelimeler
  #Given genelde ilk satırlar pre-condition stepleri için kullanılır
  # Then genelde son satırlarda verification stepleri için kullanılır
  #NOTE: teknik olarak istenilen kelime istenilen stepte kullanılır. ama anlam karmasası olmaması için bu adımlar takip edilir
  

//runner class
//bu sinif test caseleri run etmek için kullanilir
//ve configurationslar için kullanınır

@RunWith(Cucumber.class)
@CucumberOptions( 
        features = "./src/test/resources/features",
         glue="stepdefinitions" ) not features ve step definitions ayni paket altında olduğundan src/test.. ile başlamadık
      tags="@google_search"
     dryRun=false	

public class Runner {


}

**runner classı stepdefination ve features dosyasını baglar ve run eder.
*1-Feature file dosyası oluştur.ilkfeaturefile.feature
*2-Runner clasını run et
*3-console den missing step definitions ları kopyala
*4-stepdefinitions klasöründe  googlestepdefinition clası oluştur ve consolden kopyaladıklarımız yapıştir  ve import et anotasyonları
Feature: ilk feature file

  Scenario: iphone_arama

  Given kullanici google gider
  When kullanici iphone için arama yapar
  Then sonuclarda iphone oldugunu dogrular- 
*5-    @Given("kullanici google gider")
    public void kullanici_google_gider() {
        Driver.getDriver().get(ConfigReader.getProperty("google_url"));
    }

    }

not:page sayfsında elementlerin locate lerini yazıyoruz TESTNG GİBİ
**TANIMLANMAMIŞ ADIM OLURSA TEST FAİL VERECEKTİR.featuresları yazarken boşluk karakter harf herşeye dikkat etmek lazım
**testler codlar feature file deki sıralamaya göre çalışır.step definitions na göre değil
**then when hepsi aynı olsa fark etmez önemli olan parantez içinin aynı olması gherken kısmi

-When,Then, And,Given,Rule,Example,Background,Scenario Outline,Examples ->gherken dili
** """ doc String
**  | data Tables-@Tag-#comments

*****daha önce tanımladığımız step defination ve test adımlarını cucumber tekrardan yazılmaz.izin vermez.
**page altında her hangi bir yerde olması tanımlanmış olması yeterli

**Tag can be placed above the follovin Gherkin elements
Feature
Scenario
Scenario Outline
Example

 @tesla #sadece bu senaryo çalışacak bu olmasaydı ki tüm senoryalar çalışacaktı
  Scenario: TC02_google_tesla_arama

örnek:
@CucumberOptions(
        features = "./src/test/resources/features",
         glue="stepdefinitions" ,
         tags = "@tesla"
                          )


****Background 
tekrar eden preconditionlarda ilk adımlar beforemethod gibi ilk tekrar eden"
**herbir Scenario kelimesinden önce bir tek sefer çalışır.



-spark report
*mvn clean verify consoldan run etmek
*/run classında features yolunun sonuna sadece . class ismi de yazabiliriz

dryrun->false dry run yokmuş gibi hareket et demek runner methoduna eklemez isek aynı fonksiyonu görür
dryrun->thrue ise => hızlı bir şekilde tüm stepdefinitionsları tara tanımlanmamış stepdefinitionsları bul ve fail ver.
missing step definitionları kontrol eder zaman kaybının önüne geçer.önce true yapıp kaçak kod var mı bul.tanımla ve sonra dryrun false yap.


Parametrizing ff using
*kodlarımızı parametreli olarak yazdıktan sonra sadece " "  tırnak *** içindeki değeri değiştirerek test datalarını feature filedan  kontrol edebiliriz daha dinamik olacaktır böyle
**dryrun=true iken test caseler geçerse eksik adımız yok edemektir.cucumber da.

-**************SCENARİO OUTLİNE*************-----------     " <veri>   "
--aynı senaryoyu farklı değerlerle yapmak için

@scenario_outline_1
Feature: arama_feature_2

  Background: google_git
    Given kullanici google gider


    Scenario Outline: arama _testi

    When kullanici "<product>" için arama yapar
    Then sonucların "<product>" içerdiğini dogrula
    Then close the application

      Examples:
        |product |
        | tv |
        |iphone|
        | tesla |
        | cat|


  #Scenario->Scenario Outline
      # " "   ->  "<sutun ismi>"
      # Example kelimesi Scenario Outline dan sonra kullanilmalı

*birden fazla veri ile test yapmak için
*feature file kısa hale getirdik
*birden fazla kullanıcı bilgileriyle sayfaya girmek için
*birden fazla kullanıcı hesabı oluşturmak için
*birden fazla ürün aratmak için
*birden fazla excel dataprovider ı kullanacağımız her herde kullanırız

editor.datatables.net

Scenario Outline DDT DATA DRİVEN TESTİNG İÇİNkullanılır
yani benzer scenarioyu tekrar tekrar farklı datalarla çalıştırmak için kullanılır
Scenario Outline Excel ile otomasyok yapmaya benzer tek fark kullanımı daha kolaydır


CUCUMBER HTML RAPORLARI

-HTML RAPORU plugin runner  browserdan açmak lazım
-JSON RAPORU plugin runner  çift tıkla
-JUNİT RAPORU plugin runner   çift tıkla
--maven -cucumber-reporting() eklenti 
-Spark html and pdf raporları Extend rapora benzer () eklenti


pretty    bilgilerin okunaklı olması
monochrome=true consola bilgilerin okunaklı olması
json = java script kodlarının depolandığı bir dosya tipi xml html gibi


*****DATATABLE İN CUCUMBER***********
*Scenario Outline gibi. example gerek yok.data verilerimi test in her yerinde kullanabiliriz her adım da.
*.feature file scenario daki gibi fakat stepdefinitions clasında 3 farklı yol izleyebiliriz.data table hem konu adı hem data tipi olarak kullanılıyor cucumberd a
datatables ları scenario outline ve scenario ile birlikte kkullanabiliriz.

  @When("kullanici emaili ve sifresini girer")
    public void kullanici_emaili_ve_sifresini_girer(io.cucumber.datatable.DataTable dataTable) {
       //1.List<String>olarak dataları depolaya biliriz.sendKeys methodu string kabul ediyor.verileri string eçevirmeklazım
    }


**Scenario Outline ile DDT Yapılır.
test admlarını data reusable yapmak için kullanılır
encok kullanılan cucumber özelliklerindendir
Example kelimesi veri girişi için kullanılır
stepdefinitionsların data tipi STRİNG TİR
Examples lar stepdefinationslarda en sonda kullanılır


Data table ile DDT yapılabilir
Test adımlarını reusable yapmak için kullanılır
scenario outline kadar yaygın değildir
Examples kelimesi kullanılmaz
Step definitionslardaki data tipi DATATABLE stır.
data tableslar ara adımlarda kullanıla bilir.


not:datatables ve Scenario Outline birlikte kullanılabilir

**//COLLECTİONS NEDİR NASIL KULLANDIN?
list,set,queue veri depolamak için interface tir bunlar.
framworkte nasıl kullandık.
1-collectionsları özellikle çoklu data ihtiyacımız olduğunda kullanırız örneğin findElements kullanıldığında
birden fazla eleman element beklediğim için List<Webelement> kullanırız.
**yada çoklu pencere geçişlerinde getWindowHandles ile Set kullanırız
**Dropdowndaki tüm elementleri getOptions metor ile aldığımda List<Webelement>
**Frame workumda bazı utilty çok sayıda collections Kullanıyoruz EXCELLutils datalarını list e koyan methodlarıımız var
**cucumberda DataTable kullanıdığımız List veya Map koyabiliriz.
*maplar collection değildir.kendine has özellikleri var.

HOOKS NEDİR NASIL KULLANILIR
test base benzer j ıunit before ve after methodu koyuyorduk.driver veya close koyuyorduk
*herbir scenario ve scenario Outline dan önce ve sonra çalışır.
@after ve @befere bunladar j unitten değil cucumberdan geliyor.
steplerden önce değill dikkatttt. 
conditional hooks olabiliyor
--close --screenshot-

@After
public void tearDown(Scenario scenario){
            final byte[] screenshot=((TakesScreenshot)Driver.getDriver()).getScreenshotAs(OutputType.BYTES);
	
	if(scenario.isFailed()){
		scenario.attach(screenshot,"image/png" , "screenshot");

	Driver.close.Driver();
	}
	}


hooks classörünü definitions page nın altına açabiliriz fakat her run ettiğimiz de çalışacaği için bu tercih etmiyoruz
java package nın altına yeni bir hook package açıyoruz.


  @After
    public void tearDownScenarios(Scenario scenario) {
        //eger bir senaryo kalısa ekran görüntüsünü al ve rapora ekle
        if (scenario.isFailed()) {
            final byte[] failedScreenshot = ((TakesScreenshot) Driver.getDriver()).getScreenshotAs(OutputType.BYTES);
            scenario.attach(failedScreenshot, "image/png", "failedScenario" + scenario.getName());
        }
    }



glue="stepdefinitions" tek çalıştırır  fakat yeni bir paket eklemek için 
glue={"stepdefinitions" , "hooks"} yazmalıyız 
taglerde de aynı


CUCUMBER RAPORLARINI CLOUD A EKLEME
1-resources dosyasının altında cucumber properties dosyası oluştur.cucumber.properties
2 şu kodu ekle  : cucumber.publish.enable=true
3 test çalıştır bu şekilde html raporu cloud yuklenecektir. fakat GitHub ile giriş yapılmaz ise 24 saat içinde silinecektir.bu yüzden github dan girelim
4 Login with github a tıkla Authorize SmartBear
5 creat collection
6 tokeni cucumber.properties e ekle
7 testi çalıştır Collections klasöründe raporlar oluşacaktır

birden fazla collection oluşturabiliriz.rapora özel dosya.
cloud da bu rapor editlenebilir.paylaşabiliriz
https://reports.cucumber.io/
───────────────────────────────────────────────────────────────────────────────────┐
│ Share your Cucumber Report with your team at https://reports.cucumber.io          │
│ Activate publishing with one of the following:                                    │
│                                                                                   │
│ src/test/resources/cucumber.properties:          cucumber.publish.enabled=true    │
│ src/test/resources/junit-platform.properties:    cucumber.publish.enabled=true    │
│ Environment variable:                            CUCUMBER_PUBLISH_ENABLED=true    │
│ JUnit:                                           @CucumberOptions(publish = true) │
│                                                                                   │
│ More information at https://cucumber.io/docs/cucumber/environment-variables/      │
│                                                                                   │
│ Disable this message with one of the following:                                   │
│                                                                                   │
│ src/test/resources/cucumber.properties:          cucumber.publish.quiet=true      │
│ src/test/resources/junit-platform.properties:    cucumber.publish.quiet=true  

feature filelere birden fazla @tag atayabiliriz.  @smoke test @regression test


EXCEL AUTOMATİON İN CUCUMBER testng mantığı ile aynı yapılır.

**************RERUN PLUGİNG******************************
testng de listenerları kullanmıştık 
kalan test olursa bir raporla oluşur.Rerun plugin bu  işi sağlar
****"rerun:target.failedRerun.txt" bu file içinde kalan scenariolar olacak.
-tüm test caselerin geçmesi durumunda txt dosyasında scenario bulunmaz.

target/her seferinde test run da yeniden oluşacağı için screenshotları ve raporları oraya koymaz isek daha iyi olur.

PARALEL TESTİNG
-aynı anda birden fazla browser da test caseleri çalıştırma.
thread:kod kod dizi 3
tread safe: aynı anda bir den fazla testi çalıştırma kodlar karışmaz

paralel test yöntleri
cucumbe                       frame workte ayarla yapılır
testng                            frame workte ayarla yapılır
selenium grid
Jenkins

sauce Labs                                   ücretli
Browser Stack                         ücretli

1-*pom.xml le plugin eklememiz lazım
**Sure plugin  cucumbera paralel test yapma özelliği getiriyor
** Failsafe plagin     herhangi bir testtin fail etmesi durumunda diger testlerin çalışmasını sağlar.

2-sonra birden fazla Runners oluşturup bu runnerları aynı ANDA MAVEN COMMEND ile çalıştırarak paralel test yapılır
3-terminalden maven projesini çalıştırmak için mvn clean verify kullanılacak
4-report of plugin ekle. yani 3 plugin ekle cucumber-report
-**daha sonra 3 adet paralel test için runtest classı kurduk cucumber frame workunde.hooks dosylarını sildik sıkıntı çıkarıyor.

**dependency :clasları ve methodlarını verir büyük APİ BUNDALAR tool.dosyalar
plugins:daha sınırlı özellikler getirir.örneğin rerun pluging,cucumber plugins,xml file,json plugin.dependecylere benziyor ama daha kısıtlı.aksesuar gibi

**burda yazılan test taglerinden en az bir tane featureslarda kullanılmak zorunda .aksi takdir de çalışmaz.

*=yıldız contains eğer bir kelime *serdar  any anlamında serdar kelimesini içeriyor sa al. /. öncesi dahil
--pluginsler
 <build>
 <plugins></plugins>
 </build> yapısında eklenir.

**terminal*Power Shell/CMD kullanarak maven kodu ile testleri çalıştır.
mvn clean verify
mvn clean install

**bu işlemler için en başta bilgisayara apache-maven kurmak lazım
1-apache-maven google a yaz. dowload -versionlardan 2.seç- indir .winzip olarak gelecek.dosyaya çevir ve program files dosyasına ekle.  .bin gir ve adresi kopyala
2-edit enviroment ta gir . path tıkla new ve yapıştır.
3sonra cmd den mvn -v enter
**calışacak testlerin ismini daha doğrusu içerigini plugin in içinde belirtiyoruz ve runner da tag adlarını ona göre koyuyoruz.
-paralel testler maven lifeclic dan çalıştırılabilir.


***********************************Spark Report*************************

extend reportun kardeşi.
maven clean verify a gerek kalmayacak.
kuruulumm

1-resources klasoründe extent-config.xml dosya  burda da rapora yardımcı şeyler tanımlanır thema protokol başlık https veya http
2-resources klasöründe extend.properties  ***bu iki dosya birbiriyle uyum içinde çalışacak  asıl raporu bu yapar
3-Spark report dependency pom a ekle  :https:mvnreporsitory.com/artifact/tech.grasshopper/extentreports-cucumber7-adapter/1.6.0
4-spark report plugini Runner a ekle
"com.aventstack.extentreportscucumber.adapter.ExtentCucumberAdapter:"




#SCREENSHOT PATH
screenshot.dir=test-output/
screenshot.rel.path=../                  relative path test out put dosyasını bul nerede olursa olsun

adapter dependency gibi cucumber4 kullanacağız

html raporunda ekran görüntüleri büyüyor.pdf te olmuyor


cucumberda raporlama
1-runers da cucumber plugin Html,json,xml
2-extent spark report
dependency
configurasyon dosyaları
3-maven clean verify html raporları consoldan
ekran görüntüleri raporlara nasıl eklenir
hooks classta @After metotunun içinde kod ile
ayrıca oluşturulan bir steple Then ekran görüntüsü al ile olabilir
**test case fail ettiğinde ne yapılır

Framework Tipleri
-**Data Driven
çok sayıda data ile test edilir.excell data,database data,xml data,scenario outline veya datatable dan data kullanarak yapabiliriz
**-Keyword Driven
excel işin merkezinde dir.-test step-test object:web page object/element,username,password
action:such a click ,open browser,input 
test data
--**Hybrid Framework
BDD+DDD   Data driven test +behavior driven test
--**BDD Framework
önce behavior(fonksiyon,özellik,davranış)tanımlanır sonra kod yazılır cucumber gibi


*****************API**********************************
request---->respond
API testi ,uygulaması görümün üzerine odaklanmaz.

örnegin cucumber frame work umuzde hem api hem data base testi, hemde ui testi yapabiliriz
1-user interface ile create /update/delete sonrası / API ile create update delete yapıp UI,API,DATABASE TESTİ YAPABİLİRİZ/ DATABASE DE SQL kullanarak veri oluşturulabilir./insert into/update/
*uı arama işsevselliğini kullanra verilerin data base olup olmadığını test edebiliriz
*API request kullanarak verilerin database de olup olmadığını kontrol edebiliriz RESTASURE LİBRARY JSON DATA KULLANIRIZ
*SQL select queru kullanarak verilerin database de olup olmadığını kontrol edabilir.JDBC SQL

API VE WEBS SERVİSLERİ ARASINDAKİ FARK
web serviceler internet varsa yoksa apı .
HTTP hyper text tranfer protocol 

1-her apı testleri ile http status codes larını doğrulayacağız
2-data veri doğruluğu

HTTP STATUS CODLARI

200  Başarılı HTTP istekleri için standar yanıtıdır
201 bir ögenin başarı ile oluşturulduğunu belirtir
204 içerik yok.gövdesinde hiçbir şeyin döndurülmediği başarı kodu
400 bad request hatalı sözdizimi aşırı boyut veya başka bir işlemci hatası nedeniyle istek işlenemiyor
403 yasak istemcinin kaynağa erişimi yok
404 bulunamadı kaynak şu anda bulunamadı.silinmiş veay henüz mevcut değil
500 dahili sunucu hatası

testi manuel yapıyorsak POSTMAN
otomasyon için SOAP UI xml temellidir.platformlardan bağımsızdır. farklı teknolojiler ve programlama dilleri ile farklı işletim sistemlerinde çalışan uygulamar arasında iletişim kutmak için bir yol veya biçim sağlar
soap bilgileri xml formatında kayıt eder  APİ   java->xml->phton bu sırayı takip eder dilleri çevirir.
*Rest/Rest Ful kullanacağız biz.
otomasyon yazmadan önce postmande manuel test yapacağız.
*elinizde endpoint i varsa manuel test yapabilirsiniz.

Repretentional State Transfer

<customer>                                                         						{
     <customer_ıd>1001<customer_id>							"customer_id:101,
     <customer_name>1001<customer_name>						"customer_name: "Mark Star"
										} 	JSON FORMAT(KEY Value)
</customer>  XML format


1-
GET : ready-only
POST : creat
PUT : update
DELETE :clean
PACTH : partially update              

CRUD operations 

2-HEADER :data hakkında bilgiler meta data başlık bilgileri.
3-path(yol) Endpoint/url/uri
requestler işlemin gerçekleşeceği bir kaynağa giden yolu içermelidir.
endpoint :www.fashionboutique.com/customers


endpointlerin bulunduğu sayfaya swager dökümanı denir.bu sayfalar bir uygulama değil yol haritası tester için API testi için
sayfasın basında base url vardır.üzerine  dökümandaki kodları yazıp işlemleri yaparız.

get request->> swager dokumadan workspace-getnew request-> send
post request-->> swagger dok. oku->post/pet/body

run collection
bekleme süresi ,hergün aynı saatee istediğim kadar çalıştırabiliriz postman den

-oluştur oku update et sil run collectionları kkullan. test claslarını ekle.wiev. collectionları masaüstüne alabiliriz veya export edebilirim.masa  üstündeki workspace leri direk postmana atabiliriz.
olmayan bir şeyi silmeye çallıştığnda fail verir 404 verir

**rest assured dependenci yi ekle
main methodta given() ile başlıyoruz.get() methoduyla içine endpoint koyarak tabiki request yapıyoruz cevabı Response interface veriyor.
gelen response direk yazdırdak hash kodunu verir. prettyprint olarak yazdır

--otomasyon kodları yazmı için şu adımları izlemek gerekir
a)gereksimlerianlama
b)Test case yazımı
test case yazmak için Gherken language kullanılır
1-Given: ön koşullar --->endPoint ,Body...
2-When :  yapılacak işlemler -->get put delete ....
3-Then :assertion close
4-And : art arda kullanılan aynı işlemeler için

otomasyon kodları yazma
-<<set the url   ENDPOİNT i kur
--<<set the expected data---beklenen veriyi kur

--<< send the request and get the response
--<< do assertion  doğrulama yap

get requestten sonra gelen response tan response. date, haders,time,status code ,content type

1set the url
2 set the expected data
3 send the request and get the response
4-do asssertion then() methodu ile header kısmının tamamını assert edebiliriz.

proje dilii ile iligi sıkıntı olursa pom xml le 
<argLine>-Duser.language=en</argLine> eklenmeli
*body içinde bir veriyi assert edersek gelen responseu asString methoduyla stringe çevirip contains methoduyla işlem yapabiliriz
//to string kullanmadık asString kullanmaliyız

body i string e çevirip assert ediyoruz.
200 gibi seyleri then ile yapıyoruz

bady için hamcrest matcher -core matcher dan methodlar ile doğrulayacağız EqualTo gibi.


        //tek body() methodu içinde çoklu assertion yaprak soft assertion yapabiliriz.tüm fail durumları hakkında bilgi alabiririz
        //çoklu body methodları ile hard assertion yapmış oluruz ilk fail da çalışma durur sonra ki kodlar çalışmaz

request specification base_urls her request te tekrarlan ne var ise buraya koyacağız
base_urls altında yeni bir class açıyoruz. test classına extends edeceğimiz.
bu classta ResquestSpecification interface sinden spec objensi oluşturuyoruz. new RequestSpecBuilder constructer ın kullanıyoruz.sonra bunu @Before classta assing ediyoruz build yapmayı unutmuyoruz.
base url üstüne ekleyeceğimiz kısımları param veya params ile ekliyoruz
.her apı için ayrı bir class açılacak reuseable method oldu

body içinden userId çağırdığımda ilk örnekte bir adet var mı ama şimd birden fazla var bunun için assert methodları değişecek dikkat
content type genellikle veri girerken kullanacağız.given den sonra ekleyeceğiz

 //hasSize()=eleman sayısını assert eder
    //hasItem()=contains methodu gibi bir objenin içerilip içerilmediğini assert eder_import static org.hamcrest.CoreMatcher
    //hasItems()s=containsAll gibi birden fazla objenin içerilip içerilmediğini assert eder

https://google.com/search?q=techpro&faf               soru işareti le quary parametresi and iile birbirine bağlarız önemli

//  response.then().statusCode(200).body("bookingid",hasSize(greaterThan(0)));
 assertTrue( response.asString().contains("bookingid"));

**//aldığımıs response u jsonPath objesine  çevirip içinde ki tüm elemanlar üzerinde manipülasyon yapabiliriz
JsonPath jsonpath=response.jsonPath()
response.asString() te yaptığımız gibi ama jsonpath daha çok manipule imkanı tanır bizlere

 //soft assertion yapmak için test ng dependencies i kullanmak lazım junite soft assertion yapamıyoruz
jsonpath kullanıyoruz bunda

//GROOVY LANGUAGE /////////

ÇOKLU gelen json dataların içinden quary params gibi veri süzmeye yarar.
assertion kısmını dinamik yapmak için datalarımızı set the expected data kısmında hazırlamamız gerekebilir.bu kısmı genelde put ve posta kullanacağız
jsonPath te gelen dataları list olarakta alabiliriz. string int vb
JsonPath datalarını liste koyup path belirtmez isek tüm dataları list olarak verir
object türündeki bir sayıyı int bir sayıyla toplayamayız.bunun için explict narrowing yani type casting yapmamız lazım

 List<Object> list= jsonPath.getList("findAll{it.id>190}.id");//bana tüm id leri list halinde verecek
        
        //groovy language }.koyup ne istiyorsam onu larız findAll{it.id>190}.id-findAll{it.id>190}.title gibi

java temelli bir programla dildir.jsonPath de eleme yapar groovy


///////put request code in otomation**************
bizleri bir endPoint bir de body lazım bu yüzden given kısmında bunlar verilir
payload gönderilecek data. expected datamız string dönüşturülebilir ama tavsiye edilmez.

payload map olarak aldığımız da dönüştürücü eklememiz lazim  .Gson,Johnzon, Yasson, Jackson(databind) maven reporstory den 
java objesi olan map jsona dönüştürüldü gson yardımı ile.
 Map<String,Object>actualData=response.as(HashMap.class);//Gson kullanarak json datayı map e çevirdik
Gson sayıları double olarak getiriyor dikkat et bunun için json dependencies ekliyoruz

put reqest  post ile aynı adımları izliyoruz. serilization ve de-serilizationları unut ma. gönderdiğimiz ve aldığımız dataları map ile gönderiyoruz.

endpointlerimizi otomasyona dökmeden postman de manuael test yapıyoruz
serialization gson jackson java json a çeviriyor

deserialization json data java döndürüyor

**///////
response.body(path,Hamcrest Matchers(hasItem(),....))  ->datayı dışarı alıp kullanamııyoruz.sadece karşılaştırma yapıyoruz
response.jsonPath().getList()/getString()         ->datayı dışarı alabiliyoruz.kullanabiliyoruz manipule edebiliyoruz
response.jsonPath().getList()/getString()
response.as(HashMap.class)->Gson
response.as(Pojo.class)
			Response.asString
ObjectMapper().readValue(String data,HashMap.class)
ObjectMapper().readValue(String data,Pojo.class)
///////***********

***  Object obj=new HashMap<String ,String>();
     obj.get()--->yapamıyoruz parent child ın methodlarına sahip değil castin yapmaliyız dikkat

bunun için ((Map)obj).get("abc"); olmalı

maplerde value değerini Object yaptığımız da aynı şey olur .data tipi object ise implicity narrowing yapmaliıyız type casting
**object kullanırasan type castingleri unutma

**method parametrelerinden birini koymayacak isek ana methoda if ile çözebiliriz null değil ise diyerek
gelen datalar için map yapmamıza gerek yok çünkü de serilization bizim için yapar gson dependency
maplerde hergelen value obje olarak gelecek bu yüzden type castin yap. örnegin sub string de yapabilirz.
//put tüm datayı değiştirir eksik gönderiri sek siler.

//patch kısmı updata yapar
mevcut methodlarımızda patch için   if null kısımlarını kullandık unutma çünkü bütün dataları girmeyeceğiz
int data null ataya mıyoruz wraper class kullanmak gerekir
object  class ta  equalsTo diye bir method var 

APİ=     PROJECT İNTERFACE
//////////////////////POJO CLASS   payload oluşturma///////////////////////////////////
PLAİN OLD JAVA OBJECT
class bir kalıp * ***her class bir data tipidir aynı zamanda
**bir classtaki variablelara obje oluşturunca yeni değerler atayabiliriz.bir classtan variable private olmalı constructerlar oluşturmalıyız. bir boş constructer oluşturmalıyız bazı değerler null olacağı için
**her variable key value değeri  olarak alacağız.
**inner değerler için map mantığıyla yeni bir pojo clası yapacağız
**defoult const. de serilization hata alırız dikkat
--her clasın görünmeyen bir const. vardır.
***costructer parametreli yapmamızın sebebi direk obje oluştururken değer atamak için.ayrıca bir obje oluşturulabilir objenin değerlerini setter lar ile ataya biliriz.
tostring methodu over ride yaptığı için objeyi sout içine koyayrak yazdıra bilirim**
**expected data mın data tipi her ne ise gelen response u ona çevirmem lazım
**jackson.databind.exc.UnrecognizedPropertyException: alabiliriz çünkü pojo clasında olmayan değer response olarak geldi tanınmayanları ignore et.
@JsonIgnoreProperties(ignoreUnknown = true) pojo clasının başına koy.

///groovy//
list json döndüğünde groowy aklımıza gelsin.
gelen data pojo class veya map ile işlem yapılamayak gibi ise klasik yöntemle yap 

   Given
          1)  https://restful-booker.herokuapp.com/booking
          2)   {
                "firstname": "Ali",
                "lastname": "Can",
                "totalprice": 999,
                "depositpaid": true,
                "bookingdates": {
                    "checkin": "2021-09-21",
                    "checkout": "2021-12-21"
                 },
                 "additionalneeds": "Breakfast"
             }
        When
          I send POST Request to the URL
       Then
          Status code is 200
      And
          Response body is like {
                                  "bookingid": 16,
                                  "booking" :{
                                        "firstname": "Ali",
                                        "lastname": "Can",
                                        "totalprice": 999,
                                        "depositpaid": true,
                                        "bookingdates": {
                                            "checkin": "2021-09-21",
                                            "checkout": "2021-12-21"
                                        },
                                        "additionalneeds": "Breakfast"
                                     }
                                  }

//yukaridaki post islemini yaptığımızda gelen response u pojo.class olarak çevirdiğimizde 3 pojo yapmamız lazım.gelen cevap id ve booking i ignore edersek alt kısımdaki pojo verileri null gelir.


//////////////OBJECT MAPPER/////////////////////////
***as.()  ile yaptığımız işi bu sefer ObjectMapper ile yapacağız.pojo clasa veya map e çeviriyoruz

 Map<String,Object>actualData = new ObjectMapper().readValue(response.asString(), HashMap.class); objectmapper objesinde readValue methodunu kullanıp gelen json datayı map e çevirdik burda

/objectMapper kullanarak response ı java objesine çeviriyoruz
        //readValu methodu ilk parametresi String 2. parametreye çevrilecek data tipi gelir

  public static <T> T convertJsonToJava(String json,Class<T>cls){//GENERİC METHOD

        try {
       return      new ObjectMapper().readValue(json, cls);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }

as() methoduyla sadece response çevirebiliriz.ama ObjectMapper ile expected datayı da istediğimiz data tipine çevirebiliriz
//set the expected data
        //ObjectMapper objesinden readValue methodu kullanak expected datayı oluşturabiliriz.
        //json datay " " aradına aldık mı string olur


****authorization yetki
****otantification  kimlik belirtmek
method not allow diyorsa data silinmiş olabilir id yeniden alabiliriz postman
created silindi delete mesajıdır.
forbidden token istiyor demektir

token oluşturmaktan sa outhorization kısmına token üretmek için istenilen bilgileri girelim

package tan smoke testleri çalıştıra biliriz.fakat natural order olarak çalışacağı için bizim istediğimiz şeyler olmayabilir bu yüzden
bir runner class oluşturuyoruz.paketin içine

spec ten sonra addHeader eklemiz lazım token eklemek için

pojo clastaki variablara assing yapmaz isek bizim objemiz içinde hepsi olur ama null olarak gelir.
bu yüzden partial yani patch yaptığımızda kaç variable değiştireceksek o kadar variable bir pojo hazırlamamız lazım
ama en iyisi böyle kismi işlerde map ile çalışmaktır.
**boolean ve int null atanamaz bu yüzden wraper yapmamız lazım














